# Архитектурная консультация: MCP + Smithery vs текущая архитектура

**Дата:** 2026-02-16  
**Контекст:** Nano Bot V-2.0 — гибридная архитектура (main bot + nanobot gateway)

---

## 1. Текущая архитектура (краткий обзор)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         main.py (Nano Bot V-2.0)                         │
├─────────────────────────────────────────────────────────────────────────┤
│  Telegram → CommandHandler → { adapter shortcuts | LLM actions | gateway }│
│                                                                          │
│  Адаптеры (локальные):                                                    │
│  • GmailAdapter    — OAuth2, credentials.json, token.json, gmail.readonly│
│  • VisionAdapter   — скриншоты, OCR                                       │
│  • BrowserAdapter  — Playwright                                           │
│  • SystemAdapter   — безопасные команды в workspace                       │
│  • TelegramAdapter — ввод/вывод                                           │
│                                                                          │
│  gateway_bridge → nanobot AgentLoop — автономные задачи (код, файлы)      │
└─────────────────────────────────────────────────────────────────────────┘
```

**Ключевые находки по кодовой базе:**
- Уже есть `MCPAdapter` (использует `manus-mcp-cli`), но он **не подключён** к `main.py` и `CommandHandler`
- `src/core/tool_registry.py` — реестр с поддержкой MCP, но **не используется** в основном потоке
- nanobot `ToolRegistry` — отдельная система инструментов, **без MCP**
- `gateway_bridge` и MCP — **разные концепции**: gateway = агентный режим (task → agent → result), MCP = протокол вызова инструментов

---

## 2. Техническая оценка: интеграция Smithery CLI

### 2.1 Сложность интеграции

| Аспект | Оценка | Комментарий |
|--------|--------|-------------|
| **Конфликт с nanobot gateway** | ❌ Нет конфликта | Gateway выполняет *задачи*; MCP/Smithery предоставляет *инструменты*. Разные слои |
| **Совместимость с адаптерами** | ✅ Совместимо | Адаптеры — независимые компоненты; MCP-серверы могут сосуществовать |
| **Точка входа** | CommandHandler / LLM router | Нужен планировщик: LLM решает, вызывать ли Gmail (локальный) или MCP-инструмент (Smithery) |
| **OAuth через Smithery** | Упрощает setup | Вместо `credentials.json` + `token.json` — авторизация через Smithery dashboard |

### 2.2 Архитектурная совместимость

```
Текущая схема:
  User → Handler → [ GmailAdapter | gateway_execute_task ]

Гибрид с MCP/Smithery:
  User → Handler → [ GmailAdapter (как есть) | MCPAdapter.call_tool(server, tool, params) ]
                        ↑                           ↑
                   локальный OAuth              Smithery-managed OAuth
```

Smithery CLI обычно работает как **MCP-клиент**, подключающийся к MCP-серверам. Ваш `MCPAdapter` уже вызывает `manus-mcp-cli tool call`. Интеграция Smithery = замена/дополнение источника MCP-серверов (Smithery предоставляет готовые серверы + OAuth).

**Вывод:** Интеграция технически несложная. Основная работа — настройка Smithery, добавление `[ACTION:MCP_TOOL]` в LLM и маршрутизация вызовов.

---

## 3. Риски при переходе на MCP/Smithery

### 3.1 Зависимость от третьей стороны

| Риск | Вероятность | Митигация |
|------|-------------|-----------|
| Smithery downtime | Средняя | Fallback на локальные адаптеры; кэширование |
| Изменение API/тарифов | Средняя | Абстракция за интерфейсом; возможность отключения MCP-пути |
| Vendor lock-in | Низкая | MCP — открытый протокол; серверы можно поднять локально |

### 3.2 Стоимость

- Smithery: проверьте актуальные тарифы (free tier, usage-based)
- Альтернатива: self-hosted MCP-серверы (например, `@modelcontextprotocol/servers-gmail`) — бесплатно, но нужен свой OAuth

### 3.3 Совместимость

- **Gmail custom adapter:** `gmail.readonly`, EMAIL_DATA_READONLY-теги — специфика проекта. MCP Gmail-серверы могут дать больше scope (send, delete) — нужно явно ограничивать.
- **Различия в ответах:** формат ответа MCP vs ваш `get_unread_summary()` могут отличаться — потребуется слой нормализации.
- **manus-mcp-cli vs Smithery SDK:** Уточните, как именно Smithery предоставляет клиент (CLI, SDK, HTTP). Если у них свой CLI — возможна замена `manus-mcp-cli` на `smithery` CLI.

---

## 4. Гибридный подход: новые интеграции через Smithery

**Ответ: да, это реализуемо и логично.**

Стратегия:

1. **Gmail** — оставить текущий адаптер (уже работает, контролируемые scope и security tags).
2. **Calendar, Slack и др.** — добавлять через MCP/Smithery:
   - нет ручной разработки адаптеров;
   - OAuth через Smithery;
   - быстрый доступ к множеству сервисов.

Реализация:

```
adapters = {
    "gmail": GmailAdapter(...),      # без изменений
    "mcp": MCPAdapter(...),         # для Calendar, Slack, GitHub и т.д.
}
```

В `CommandHandler` — новые shortcuts или LLM-действия:

- `[ACTION:MCP_TOOL server=google-calendar tool=list_events params={...}]`
- Роутинг: если `server` + `tool` — вызывать `mcp_adapter.call_tool()`.

---

## 5. Производительность: Smithery gateway

### 5.1 Задержки

| Этап | Локальный адаптер | Smithery/MCP |
|------|-------------------|--------------|
| Авторизация | Локальный token | Раз в сессию через Smithery |
| Вызов API | Прямо: бот → Google API | Бот → Smithery gateway → MCP server → External API |
| Сеть | 1 hop | 2+ hops |

**Оценка:** Дополнительная задержка порядка **50–200 ms** на вызов из-за proxy через Smithery. Для чат-бота обычно приемлемо.

### 5.2 Когда это критично

- Высокочастотные вызовы (десятки запросов в секунду) — возможны ограничения и лимиты.
- Real-time сценарии — предпочтительны локальные адаптеры.

Для типичного Telegram-бота задержка в 100–200 ms несущественна.

---

## 6. Рекомендации по вариантам

### Вариант A: Продолжать писать адаптеры вручную

**За:**
- Полный контроль над scope, форматом ответов, безопасностью
- Нет зависимости от внешних сервисов
- Прямые вызовы API, минимум задержек

**Против:**
- Много ручной работы на каждый сервис (OAuth, обновления API)
- Ограниченный набор интеграций

**Когда выбирать:** Несколько ключевых интеграций (2–5), где критичны кастомная логика и безопасность.

---

### Вариант B: Постепенная миграция (гибрид) — **рекомендуемый**

**За:**
- Сохранение Gmail и других проверенных адаптеров
- Быстрое добавление Calendar, Slack, GitHub через MCP/Smithery
- Ограниченный риск: fallback на локальные адаптеры
- Постепенная оценка Smithery без полного переписывания

**Против:**
- Два стиля интеграций (локальные + MCP)
- Необходимость нормализации ответов MCP под ваш UX

**План действий:**
1. Подключить `MCPAdapter` к `CommandHandler` (он уже есть, но не используется).
2. Добавить 1–2 MCP-инструмента через Smithery (например, Calendar).
3. Реализовать `[ACTION:MCP_TOOL]` в LLM и маршрутизацию.
4. Оценить latency, стоимость и UX.
5. По результатам решить: расширять MCP или дописывать локальные адаптеры для критичных сервисов.

---

### Вариант C: Полная миграция на MCP

**За:**
- Единый протокол для всех инструментов
- Максимальное использование экосистемы MCP
- Меньше своего кода для поддержки

**Против:**
- Замена работающего Gmail-адаптера (потеря EMAIL_DATA_READONLY и тонкой настройки)
- Зависимость от Smithery для основных функций
- Риск регрессий по безопасности и UX

**Когда рассматривать:** Если количество интеграций растёт (10+) и команда не готова поддерживать множество кастомных адаптеров.

---

## 7. Альтернативные решения

### 7.1 Self-hosted MCP-серверы

Использовать открытые MCP-серверы (например, из `@modelcontextprotocol/servers-*`) локально:
- Без Smithery
- OAuth и секреты у себя
- Больше контроля, больше операционной нагрузки

### 7.2 Прямой MCP SDK (без Smithery)

Использовать `mcp` Python SDK для подключения к MCP-серверам:
- Без `manus-mcp-cli` и subprocess
- Нативный async
- OAuth и серверы — свои или публичные

### 7.3 Слой абстракции (Adapter Pattern)

```
ToolFacade
  ├── GmailAdapter (local)
  ├── CalendarAdapter (local или MCP)
  └── MCPAdapter (Smithery-managed)
```

Общий интерфейс `get_events()`, `send_message()` и т.п., внутри — выбор между локальной реализацией и MCP. Это упростит будущую миграцию и A/B-тесты.

---

## 8. Итоговая рекомендация

**Рекомендуемый путь: вариант B (гибрид)** с поэтапным внедрением:

1. **Фаза 1 (1–2 недели):** Подключить `MCPAdapter` к `CommandHandler`, добавить один MCP-инструмент (например, Calendar) через Smithery.
2. **Фаза 2 (2–4 недели):** Расширить набор MCP-инструментов (Slack, GitHub), сохраняя Gmail как локальный адаптер.
3. **Фаза 3 (по мере необходимости):** Решить по каждому сервису — MCP или локальный адаптер, исходя из требований к безопасности, latency и стоимости.

Такой подход даёт быстрый доступ к экосистеме MCP при минимальном риске и сохранении полного контроля над критичными интеграциями (Gmail).
